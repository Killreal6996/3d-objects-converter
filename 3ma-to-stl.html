<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3MA → STL</title>
  <style>
    html, body { height: 100%; }
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      margin:0;background:#0f1220;color:#e6e8ef;
    }
    header{
      padding:16px 20px;border-bottom:1px solid #22253a;
      display:flex;gap:12px;align-items:center;
      height:58px;box-sizing:border-box;
    }
    main{
      display:grid;grid-template-columns:360px 1fr;
      height:calc(100vh - 58px);
    }
    .panel{
      padding:16px 20px;border-right:1px solid #22253a;background:#111427;
      box-sizing:border-box;overflow:auto;
    }
    .panel h2{font-size:16px;margin:8px 0 12px;}
    .panel .box{
      background:#0c0f1f;border:1px dashed #2a2f4a;border-radius:10px;
      padding:14px;margin-bottom:12px;
    }
    .panel label{display:block;font-size:13px;color:#aab0c5;margin-bottom:6px;}
    input[type=file]{width:100%;color:#cfd3e3;}
    input[type=number], select{
      width:100%; padding:8px 10px; border-radius:8px;
      border:1px solid #2a2f4a; background:#0b0e1b; color:#e6e8ef;
      box-sizing:border-box;
    }
    .row{display:grid;grid-template-columns:1fr 1fr; gap:8px;}
    button{
      width:100%;padding:10px 12px;border:0;border-radius:10px;
      background:#4b7cff;color:white;font-weight:600;cursor:pointer;
      margin-top:8px;
    }
    button.secondary{
      background:#1a1f36;border:1px solid #2a2f4a;color:#cfe0ff;
    }
    button:disabled{opacity:.5;cursor:not-allowed;}
    .meta{font-size:12px;color:#aab0c5;line-height:1.5;margin-top:8px;white-space:pre-wrap;}
    .error{color:#ffb4b4;}
    .ok{color:#b8ffc7;}

    .viewer{
      position:relative;
      height:100%;
      overflow:hidden;
      background:#0f1220;
    }
    #canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
    }
    .toolbar{
      position:absolute;top:12px;left:12px;
      background:#0c0f1fcc;border:1px solid #22253a;border-radius:10px;
      padding:8px 10px;font-size:12px;color:#cfd3e3;backdrop-filter: blur(4px);
      z-index:2; max-width:70%;
    }
    a.download{
      display:block;text-align:center;margin-top:10px;background:#1a1f36;
      padding:10px 12px;border-radius:10px;color:#cfe0ff;text-decoration:none;
      border:1px solid #2a2f4a;
    }
  </style>
</head>
<body>
<header>
  <strong>3ma конвертер разработанный командой BitA</strong>
</header>

<main>
  <section class="panel">
    <h2>1) Загрузка .3ma</h2>
    <div class="box">
      <label>Выберите файл .3ma:</label>
      <input id="fileInput" type="file" accept=".3ma,application/json,text/plain" />
      <div id="fileInfo" class="meta">Файл не выбран</div>
    </div>

    <h2>2) Масштабирование</h2>
    <div class="box">
      <label>Масштаб (коэффициент):</label>
      <div class="row">
        <input id="scaleInput" type="number" step="0.001" value="1" min="0.0001" />
        <select id="unitSelect">
          <option value="1">в единицах модели</option>
          <option value="0.001">мм (если модель в метрах)</option>
          <option value="0.01">см (если модель в метрах)</option>
          <option value="1">м</option>
        </select>
      </div>
      <button id="applyScaleBtn" class="secondary">Применить масштаб</button>
      <div id="scaleInfo" class="meta">Текущий масштаб: 1.0×</div>
    </div>

    <h2>3) Конвертация</h2>
    <div class="box">
      <button id="convertBtn" disabled>Конвертировать в STL</button>
      <a id="downloadLink" class="download" style="display:none;" download>Скачать STL</a>
      <div id="convertInfo" class="meta"></div>
    </div>
  </section>

  <section class="viewer">
    <div class="toolbar" id="viewerInfo">Сетка, оси и “линейка” должны быть видны сразу. Модель появится после конвертации.</div>
    <canvas id="canvas"></canvas>
  </section>
</main>

<script>
  const fileInput    = document.getElementById("fileInput");
  const fileInfo     = document.getElementById("fileInfo");
  const convertBtn   = document.getElementById("convertBtn");
  const downloadLink = document.getElementById("downloadLink");
  const convertInfo  = document.getElementById("convertInfo");

  const scaleInput   = document.getElementById("scaleInput");
  const unitSelect   = document.getElementById("unitSelect");
  const applyScaleBtn= document.getElementById("applyScaleBtn");
  const scaleInfo    = document.getElementById("scaleInfo");

  let currentScale = 1.0;

  function setScaleFromUI(){
    const s = parseFloat(scaleInput.value || "1");
    const unitMul = parseFloat(unitSelect.value || "1");
    currentScale = s * unitMul;
    scaleInfo.textContent = `Текущий масштаб: ${currentScale.toFixed(6)}×`;
    if (window.applyPreviewScale) window.applyPreviewScale(currentScale);
  }

  applyScaleBtn.addEventListener("click", setScaleFromUI);

  function parse3MA(jsonText){
    const data = JSON.parse(jsonText);
    if (!data.meshes || !Array.isArray(data.meshes) || data.meshes.length === 0) {
      throw new Error("В файле нет meshes");
    }

    const allVertices = [];
    const allTriangles = [];
    let totalTris = 0, totalVerts = 0;

    for (const mesh of data.meshes){
      const pf = mesh.preciseFactor || 1;
      const posFlat = mesh._positions || mesh.positions;
      const idxFlat = mesh._posIndexis || mesh.triangles;
      if (!posFlat || !idxFlat) continue;

      const vertices = [];
      for (let i=0;i<posFlat.length;i+=3){
        vertices.push([posFlat[i]/pf, posFlat[i+1]/pf, posFlat[i+2]/pf]);
      }

      if (idxFlat.length % 3 !== 0){
        throw new Error("Длина индексов треугольников не кратна 3");
      }

      const triangles = [];
      for (let i=0;i<idxFlat.length;i+=3){
        triangles.push([idxFlat[i], idxFlat[i+1], idxFlat[i+2]]);
      }

      allVertices.push(vertices);
      allTriangles.push(triangles);
      totalVerts += vertices.length;
      totalTris  += triangles.length;
    }

    return { fileName: data.fileName || "model", allVertices, allTriangles, totalVerts, totalTris };
  }

  function calcNormal(v1, v2, v3){
    const ax=v2[0]-v1[0], ay=v2[1]-v1[1], az=v2[2]-v1[2];
    const bx=v3[0]-v1[0], by=v3[1]-v1[1], bz=v3[2]-v1[2];
    let nx=ay*bz-az*by, ny=az*bx-ax*bz, nz=ax*by-ay*bx;
    const len=Math.hypot(nx,ny,nz)||1;
    return [nx/len, ny/len, nz/len];
  }

  function buildAsciiSTL(model){
    const lines=[];
    lines.push(`solid ${model.fileName}`);
    for (let m=0;m<model.allVertices.length;m++){
      const verts=model.allVertices[m], tris=model.allTriangles[m];
      for (const [a,b,c] of tris){
        const v1=verts[a], v2=verts[b], v3=verts[c];

        // применяем масштаб при экспорте
        const sv1=[v1[0]*currentScale, v1[1]*currentScale, v1[2]*currentScale];
        const sv2=[v2[0]*currentScale, v2[1]*currentScale, v2[2]*currentScale];
        const sv3=[v3[0]*currentScale, v3[1]*currentScale, v3[2]*currentScale];

        const [nx,ny,nz]=calcNormal(sv1,sv2,sv3);
        lines.push(`  facet normal ${nx} ${ny} ${nz}`);
        lines.push(`    outer loop`);
        lines.push(`      vertex ${sv1[0]} ${sv1[1]} ${sv1[2]}`);
        lines.push(`      vertex ${sv2[0]} ${sv2[1]} ${sv2[2]}`);
        lines.push(`      vertex ${sv3[0]} ${sv3[1]} ${sv3[2]}`);
        lines.push(`    endloop`);
        lines.push(`  endfacet`);
      }
    }
    lines.push(`endsolid ${model.fileName}`);
    return lines.join("\n");
  }

  fileInput.addEventListener("change", () => {
    downloadLink.style.display="none";
    convertInfo.textContent="";
    const file=fileInput.files&&fileInput.files[0];
    if(!file){ fileInfo.textContent="Файл не выбран"; convertBtn.disabled=true; return; }
    fileInfo.textContent=`Выбран: ${file.name} (${(file.size/1024).toFixed(1)} KB)`;
    convertBtn.disabled=false;
  });

  convertBtn.addEventListener("click", async () => {
    convertBtn.disabled=true;
    convertInfo.className="meta";
    convertInfo.textContent="Конвертирую...";

    try{
      const file=fileInput.files&&fileInput.files[0];
      if(!file) throw new Error("Файл не выбран");

      const text=await file.text();
      const model=parse3MA(text);
      const stlText=buildAsciiSTL(model);

      const blob=new Blob([stlText],{type:"model/stl"});
      const url=URL.createObjectURL(blob);
      const baseName=file.name.replace(/\.3ma$/i,"")||model.fileName;

      downloadLink.href=url;
      downloadLink.download=baseName+".stl";
      downloadLink.textContent="Скачать "+downloadLink.download;
      downloadLink.style.display="block";

      convertInfo.textContent=
        `Готово.\nMeshes: ${model.allVertices.length}\nВершин: ${model.totalVerts}\nТреугольников: ${model.totalTris}\nМасштаб: ${currentScale.toFixed(6)}×`;
      convertInfo.className="meta ok";

      if(window.renderPreview) window.renderPreview(model);

    }catch(err){
      convertInfo.textContent="Ошибка: "+err.message;
      convertInfo.className="meta error";
      document.getElementById("viewerInfo").textContent="Не удалось построить предпросмотр";
    }finally{
      convertBtn.disabled=false;
    }
  });

  // применим масштаб сразу при загрузке страницы
  setScaleFromUI();
</script>

<script type="module">
  import * as THREE from "./three.module.js";
  import { OrbitControls } from "./OrbitControls.js";

  const canvas = document.getElementById("canvas");
  const viewerInfo = document.getElementById("viewerInfo");

  let renderer, scene, camera, controls, currentMesh;
  let previewScale = 1.0;
  const rulerGroup = new THREE.Group();

  function makeTextSprite(text){
    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");
    const fontSize = 48;
    ctx.font = `${fontSize}px sans-serif`;
    const padding = 10;
    const w = Math.ceil(ctx.measureText(text).width + padding*2);
    const h = fontSize + padding*2;
    c.width = w; c.height = h;
    ctx.font = `${fontSize}px sans-serif`;
    ctx.fillStyle = "white";
    ctx.textBaseline = "middle";
    ctx.fillText(text, padding, h/2);
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({ map: tex, depthTest:false, depthWrite:false });
    const spr = new THREE.Sprite(mat);
    spr.scale.set(0.25, 0.125, 1);
    return spr;
  }

  function buildRuler({tickStep=1, tickCount=10}){
    rulerGroup.clear();

    const tickLen = 0.08;
    const mat = new THREE.LineBasicMaterial({ color: 0x9aa4c7 });
    const pts = [];

    function addTick(x,y,z, dx,dy,dz){
      pts.push(new THREE.Vector3(x,y,z));
      pts.push(new THREE.Vector3(x+dx,y+dy,z+dz));
    }

    for (let i=0;i<=tickCount;i++){
      const t = i*tickStep;

      // X axis ticks
      addTick(t,0,0, 0, tickLen, 0);
      const sx = makeTextSprite(String(i));
      sx.position.set(t, 0.18, 0);
      rulerGroup.add(sx);

      // Y axis ticks
      addTick(0,t,0, tickLen, 0, 0);
      const sy = makeTextSprite(String(i));
      sy.position.set(0.18, t, 0);
      rulerGroup.add(sy);

      // Z axis ticks
      addTick(0,0,t, tickLen, 0, 0);
      const sz = makeTextSprite(String(i));
      sz.position.set(0.18, 0, t);
      rulerGroup.add(sz);
    }

    const geom = new THREE.BufferGeometry().setFromPoints(pts);
    const lines = new THREE.LineSegments(geom, mat);
    rulerGroup.add(lines);

    // Названия осей
    const ax = makeTextSprite("X");
    ax.position.set(tickCount*tickStep + 0.4, 0, 0); rulerGroup.add(ax);
    const ay = makeTextSprite("Y");
    ay.position.set(0, tickCount*tickStep + 0.4, 0); rulerGroup.add(ay);
    const az = makeTextSprite("Z");
    az.position.set(0, 0, tickCount*tickStep + 0.4); rulerGroup.add(az);

    return rulerGroup;
  }

  function initPreview(){
    renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f1220);

    camera = new THREE.PerspectiveCamera(45, 1, 0.01, 10000);
    camera.position.set(3,3,3);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x223355, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5,8,3);
    scene.add(dir);

    scene.add(new THREE.GridHelper(20, 40, 0x2a2f4a, 0x1b1f33));
    scene.add(new THREE.AxesHelper(2));

    scene.add(buildRuler({tickStep:1, tickCount:10}));

    onResize();
    animate();

    viewerInfo.textContent = "Сетка, оси и линейка активны. После конвертации появится модель.";
  }

  function onResize(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    if (w===0||h===0) return;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener("resize", onResize);

  function animate(){
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  function buildGeometryForPreview(model){
    const positions = [];
    for (let m=0;m<model.allVertices.length;m++){
      const verts=model.allVertices[m], tris=model.allTriangles[m];
      for (const [a,b,c] of tris){
        positions.push(
          verts[a][0]*previewScale, verts[a][1]*previewScale, verts[a][2]*previewScale,
          verts[b][0]*previewScale, verts[b][1]*previewScale, verts[b][2]*previewScale,
          verts[c][0]*previewScale, verts[c][1]*previewScale, verts[c][2]*previewScale
        );
      }
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
    geom.computeVertexNormals();
    return geom;
  }

  function fitCameraToObject(object){
    const box = new THREE.Box3().setFromObject(object);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxSize = Math.max(size.x,size.y,size.z) || 1;
    const dist = maxSize * 1.5 / Math.tan((camera.fov*Math.PI/180)/2);

    camera.position.set(center.x+dist, center.y+dist, center.z+dist);
    camera.near = dist/100;
    camera.far  = dist*100;
    camera.updateProjectionMatrix();

    controls.target.copy(center);
    controls.update();
  }

  window.applyPreviewScale = function(scale){
    previewScale = scale || 1.0;
    // если модель уже на сцене — пересоберём её
    if (window._lastModelForPreview) window.renderPreview(window._lastModelForPreview);
  };

  window.renderPreview = function(model){
    window._lastModelForPreview = model;

    if (currentMesh){
      scene.remove(currentMesh);
      currentMesh.geometry.dispose();
      currentMesh.material.dispose();
    }

    const geom = buildGeometryForPreview(model);
    const mat = new THREE.MeshStandardMaterial({
      color: 0x8fb3ff, roughness:0.6, metalness:0.1, side:THREE.DoubleSide
    });

    currentMesh = new THREE.Mesh(geom, mat);
    scene.add(currentMesh);
    fitCameraToObject(currentMesh);

    viewerInfo.textContent =
      `Вершины: ${model.totalVerts} | Треугольники: ${model.totalTris} | Meshes: ${model.allVertices.length} | Масштаб: ${previewScale.toFixed(6)}×`;
  };

  requestAnimationFrame(initPreview);
</script>

</body>
</html>
